/*
Copyright (c) 2017 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003
Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module main;

import std.stdio;
import std.math;
import std.random;

import dagon;

import dmech.world;
import dmech.geometry;
import dmech.rigidbody;
import dmech.bvh;
import dmech.raycast;

import rigidbodycontroller;
import character;

BVHTree!Triangle meshBVH(Mesh[] meshes)
{
    DynamicArray!Triangle tris;

    foreach(mesh; meshes)
    foreach(tri; mesh)
    {
        Triangle tri2 = tri;
        tri2.v[0] = tri.v[0];
        tri2.v[1] = tri.v[1];
        tri2.v[2] = tri.v[2];
        tri2.normal = tri.normal;
        tri2.barycenter = (tri2.v[0] + tri2.v[1] + tri2.v[2]) / 3;
        tris.append(tri2);
    }

    assert(tris.length);
    BVHTree!Triangle bvh = New!(BVHTree!Triangle)(tris, 4);
    tris.free();
    return bvh;
}

class Wheel: Owner
{
    Vector3f suspPosition;
    Vector3f forcePosition;
    Vector3f position;
    float radius;
    float suspMaxLength;
    float suspStiffness; 
    float suspDamping;
    float suspCompression;
    float suspLength;
    float suspLengthPrev;
    float steeringAngle;
    float torque;
    float roll;
    float dirCoef;
    bool powered;
    bool steered;
    float maxSteeringAngle;
    float rollSpeed;
    bool front;
    bool isDrifting;

    Matrix4x4f transformation;

    this(Vector3f pos, bool powered, bool steered, bool front, Owner o)
    {
        super(o);
        suspPosition = pos;
        forcePosition = Vector3f(0.0f, 0.0f, 0.0f);
        radius = 0.6f;
        suspStiffness = 80000.0f;
        suspDamping = 10000.0f;
        suspCompression = 0.0f;
        suspLength = 0.0f;
        suspLengthPrev = 0.0f;
        suspMaxLength = 0.8f; //0.8f;
        steeringAngle = 0.0f;
        torque = 0.0f;
        position = suspPosition - Vector3f(0.0f, suspMaxLength, 0.0f);
        transformation = Matrix4x4f.identity;
        roll = 0.0f;
        dirCoef = 1.0f;
        this.powered = powered;
        this.steered = steered;
        maxSteeringAngle = 45.0f;
        rollSpeed = 0.0f;
        this.front = front;
        isDrifting = false;
    }
}

class VehicleController: EntityController
{
    PhysicsWorld world;
    RigidBody rbody;
    Wheel[4] wheels; // TODO: use dynamic array and let the user create wheels
    float torqueAcc;
    bool brake = false;
    float maxForwardTorque = 30000.0f; //30000.0f;
    float maxBackwardTorque = 20000.0f;

    this(Entity e, RigidBody b, PhysicsWorld w)
    {
        super(e);

        world = w;

        rbody = b;
        b.position = e.position;
        b.orientation = e.rotation;

        wheels[0] = New!Wheel(Vector3f(-1.2f, 1,  2.2f), false, true, true, this);
        wheels[0].dirCoef = -1.0f;
        wheels[1] = New!Wheel(Vector3f( 1.2f, 1,  2.2f), false, true, true, this);
        wheels[2] = New!Wheel(Vector3f(-1.2f, 1, -2.0f), true, false, false, this);
        wheels[2].dirCoef = -1.0f;
        wheels[3] = New!Wheel(Vector3f( 1.2f, 1, -2.0f), true, false, false, this);

        torqueAcc = 0.0f;
    }

    void accelerateForward(float t)
    {
        if (torqueAcc < 0.0f)
            torqueAcc = 0.0f;
        else
            torqueAcc += t;

        if (isMovingBackward)
            brake = true;
        else
            brake = false;

        if (torqueAcc > maxForwardTorque)
            torqueAcc = maxForwardTorque;

        uint numPoweredWheels = 0;
        foreach(i, w; wheels)
        if (w.powered)
            numPoweredWheels++;
 
        foreach(i, w; wheels)
        if (w.powered)
            w.torque = torqueAcc / cast(float)numPoweredWheels;
    }

    void accelerateBackward(float t)
    {
        if (torqueAcc > 0.0f)
            torqueAcc = 0.0f;
        else
            torqueAcc -= t;

        if (isMovingForward)
            brake = true;
        else
            brake = false;

        if (torqueAcc < -maxBackwardTorque)
            torqueAcc = -maxBackwardTorque;

        uint numPoweredWheels = 0;
        foreach(i, w; wheels)
        if (w.powered)
            numPoweredWheels++;
 
        foreach(i, w; wheels)
        if (w.powered)
            w.torque = torqueAcc / cast(float)numPoweredWheels;
    }

    void steer(float angle)
    {
        foreach(i, w; wheels)
        if (w.steered)
        {
            if (w.front)
                w.steeringAngle += angle;
            else
                w.steeringAngle += -angle;

            if (w.steeringAngle > w.maxSteeringAngle)
                w.steeringAngle = w.maxSteeringAngle;
            else if (w.steeringAngle < -w.maxSteeringAngle)
                w.steeringAngle = -w.maxSteeringAngle;
        }
    }

    void resetSteering()
    {
        foreach(i, w; wheels)
        if (w.steered)
        {
            if (w.steeringAngle > 0.0f)
                w.steeringAngle -= 2.0f;
            if (w.steeringAngle < 0.0f)
                w.steeringAngle += 2.0f;
        }
    }

    void downRaycast(Vector3f pos, Vector3f down, out float height, out Vector3f n)
    {
        CastResult castResult;
        if (world.raycast(pos, down, 10, castResult, true, true))
        {
            height = castResult.point.y;
            n = castResult.normal;
        }
        else
        {
            height = 0;
            n = Vector3f(0.0f, 1.0f, 0.0f);
        }
    }

    void updateWheel(Wheel w, double dt)
    {
        w.transformation = rbody.transformation * 
            translationMatrix(w.position) * rotationMatrix(Axis.y, degtorad(w.steeringAngle));

        Vector3f wheelPosW = rbody.position + rbody.orientation.rotate(w.suspPosition);
        float groundHeight = 0.0f;
        Vector3f groundNormal = Vector3f(0, 1, 0);
        Vector3f down = -w.transformation.up;
        downRaycast(wheelPosW, down, groundHeight, groundNormal);
        w.forcePosition = Vector3f(wheelPosW.x, groundHeight, wheelPosW.z);

        float suspToGround = wheelPosW.y - groundHeight;

        bool inAir;

        float invSteepness = clamp(dot(groundNormal, Vector3f(0, 1, 0)), 0.0f, 1.0f);

        if (suspToGround > (w.suspMaxLength + w.radius)) // wheel is in air
        {
            w.suspCompression = 0.0f;
            w.suspLengthPrev = w.suspMaxLength;
            w.suspLength = w.suspMaxLength;
            w.position = w.suspPosition + Vector3f(0.0f, -w.suspMaxLength, 0.0f);

            inAir = true;

            w.isDrifting = false;
        }
        else // suspension is compressed
        {
            w.suspLengthPrev = w.suspLength;
            w.suspLength = suspToGround - w.radius;
            w.suspCompression = w.suspMaxLength - w.suspLength;
            w.position = w.suspPosition + Vector3f(0.0f, -w.suspLength, 0.0f);

            float springForce = w.suspCompression * w.suspStiffness;
            float dampingForce = ((w.suspLengthPrev - w.suspLength) * w.suspDamping) / dt;

            float normalForce = springForce + dampingForce;

            Vector3f upDir = w.transformation.up;
            Vector3f springForceVec = upDir * springForce;
            Vector3f dampingForceVec = upDir * dampingForce;

            rbody.applyForceAtPos(springForceVec, w.forcePosition);
            rbody.applyForceAtPos(dampingForceVec, w.forcePosition);

            Vector3f forwardDir = w.transformation.forward;
            Vector3f sideDir = w.transformation.right * w.dirCoef;

            float forwardForce = w.torque / w.radius;

            Vector3f radiusVector = w.forcePosition - rbody.position;
            Vector3f pointVelocity = rbody.linearVelocity + cross(rbody.angularVelocity, radiusVector);
            float sideSpeed = dot(pointVelocity, sideDir);
            float sideFrictionForce = -sideSpeed * rbody.mass * 0.9f;

            rbody.applyForceAtPos(forwardDir * forwardForce, w.forcePosition);
            rbody.applyForceAtPos(sideDir * sideFrictionForce, w.forcePosition);

            inAir = false;

            w.isDrifting = abs(sideSpeed) > 2.0f;
        }

        if (!brake)
        {
            if (!inAir)
            {
                float forwardSpeed = dot(rbody.linearVelocity, rbody.transformation.forward);
                w.rollSpeed = forwardSpeed / w.radius;
            }
            else
            {
                if (w.powered && w.torque != 0.0f)
                    w.rollSpeed = w.torque * dt;
            
                w.rollSpeed *= 0.99f;
            }

            w.roll += radtodeg(w.rollSpeed) * dt;
            if (w.roll > 360.0f) w.roll -= 360.0f;
        }
        else if (!inAir)
            w.isDrifting = true;

        w.torque = 0.0f;
    }

    bool isMovingForward()
    {
        float forwardSpeed = dot(rbody.linearVelocity, rbody.transformation.forward);
        return forwardSpeed > 0.0f;
    }

    bool isMovingBackward()
    {
        float forwardSpeed = dot(rbody.linearVelocity, rbody.transformation.forward);
        return forwardSpeed < 0.0f;
    }

    bool isStopped()
    {
        float forwardSpeed = dot(rbody.linearVelocity, rbody.transformation.forward);
        return abs(forwardSpeed) <= EPSILON;
    }

    Vector3f position()
    {
        return rbody.position;
    }

    Quaternionf rotation()
    {
        return rbody.orientation;
    }

    void fixedStepUpdate(double dt)
    {
        foreach(i, w; wheels)
            updateWheel(w, dt);
        
        if (torqueAcc > 0.0f)
            torqueAcc -= 0.5f;
        else if (torqueAcc < 0.0f)
            torqueAcc += 0.5f;
    }

    override void update(double dt)
    {
        entity.position = rbody.position;
        entity.rotation = rbody.orientation; 
        entity.transformation = rbody.transformation;
        entity.invTransformation = entity.transformation.inverse;
    }
}

class CarView: EventListener, View
{
    VehicleController vehicle;
    Vector3f position;
    Vector3f offset;
    Matrix4x4f _trans;
    Matrix4x4f _invTrans;

    this(EventManager emngr, VehicleController vehicle, Owner owner)
    {
        super(emngr, owner);

        this.vehicle = vehicle;
        offset = Vector3f(0.0f, 0.0f, -7.0f);
        position = vehicle.position + offset;
    }

    void update(double dt)
    {
        processEvents();

        Vector3f tp = vehicle.position + vehicle.rotation.rotate(offset) + Vector3f(0, 3, 0);
        Vector3f d = tp - position;
        position += (d * 10.0f) * dt;

        _trans = lookAtMatrix(position, vehicle.position + Vector3f(0, 2, 0), Vector3f(0, 1, 0));
        _invTrans = _trans.inverse;
    }

    Matrix4x4f viewMatrix()
    {
        return _trans;
    }
    
    Matrix4x4f invViewMatrix()
    {
        return _invTrans;
    }
    
    Vector3f cameraPosition()
    {
        return position;
    }
}

class TestScene: BaseScene3D
{
    FontAsset aFont;

    TextureAsset aTexImrodDiffuse;
    TextureAsset aTexImrodNormal;
    
    TextureAsset aTexStoneDiffuse;
    TextureAsset aTexStoneNormal;
    TextureAsset aTexStoneHeight;
    
    TextureAsset aTexStone2Diffuse;
    TextureAsset aTexStone2Normal;
    TextureAsset aTexStone2Height;
    
    TextureAsset aTexCrateDiffuse;
    
    TextureAsset aTexParticle;
    
    TextureAsset aTexCarDiffuse;
    TextureAsset aTexCarNormal;
    
    OBJAsset aCastle;
    OBJAsset aImrod;
    OBJAsset aCrate;
    OBJAsset aSphere;
    
    OBJAsset aCar;
    OBJAsset aWheel;
    
    IQMAsset iqm;
    
    Entity eMrfixit;
    Actor actor;

    ShadelessBackend shadelessMatBackend;
    SkyBackend skyMatBackend;
    float sunPitch = -45.0f;
    float sunTurn = 0.0f;
    
    FirstPersonView fpview;
    CarView carView;
    bool carViewEnabled = false;
    
    Entity eSky;
    
    PhysicsWorld world;
    RigidBody bGround;
    Geometry gGround;
    float lightBallRadius = 0.5f;
    Geometry gLightBall;
    GeomEllipsoid gSphere;
    GeomBox gSensor;
    CharacterController character;
    GeomBox gCrate;
    VehicleController vehicle;
    Geometry gBox;
    BVHTree!Triangle bvh;
    bool initializedPhysics = false;
    
    Entity[4] eWheels;
    
    Framebuffer fb;
    Framebuffer fbAA;
    PostFilterFXAA fxaa;
    PostFilterLensDistortion lens;
    
    Entity eParticles;
    
    TextLine dynamicText;
  
    Color4f[9] lightColors = [
        Color4f(1, 1, 1, 1),
        Color4f(1, 0, 0, 1),
        Color4f(1, 0.5, 0, 1),
        Color4f(1, 1, 0, 1),
        Color4f(0, 1, 0, 1),
        Color4f(0, 1, 0.5, 1),
        Color4f(0, 1, 1, 1),
        Color4f(0, 0.5, 1, 1),
        Color4f(0, 0, 1, 1)
    ];

    this(SceneManager smngr)
    {
        super(smngr);
    }

    override void onAssetsRequest()
    {
        aFont = addFontAsset("data/font/DroidSans.ttf", 14);
    
        aTexImrodDiffuse = addTextureAsset("data/textures/imrod-diffuse.png");
        aTexImrodNormal = addTextureAsset("data/textures/imrod-normal.png");
        
        aTexStoneDiffuse = addTextureAsset("data/textures/stone-albedo.png");
        aTexStoneNormal = addTextureAsset("data/textures/stone-normal.png");
        aTexStoneHeight = addTextureAsset("data/textures/stone-height.png");
        
        aTexStone2Diffuse = addTextureAsset("data/textures/stone2-albedo.png");
        aTexStone2Normal = addTextureAsset("data/textures/stone2-normal.png");
        aTexStone2Height = addTextureAsset("data/textures/stone2-height.png");
        
        aTexCrateDiffuse = addTextureAsset("data/textures/crate.png");

        aTexParticle = addTextureAsset("data/textures/particle.png");
        
        aCastle = New!OBJAsset(assetManager);
        addAsset(aCastle, "data/obj/castle.obj");
        
        aImrod = New!OBJAsset(assetManager);
        addAsset(aImrod, "data/obj/imrod.obj");
        
        aCrate = New!OBJAsset(assetManager);
        addAsset(aCrate, "data/obj/crate.obj");
        
        aSphere = New!OBJAsset(assetManager);
        addAsset(aSphere, "data/obj/sphere.obj");
        
        assetManager.mountDirectory("data/iqm");
        iqm = New!IQMAsset(assetManager);
        addAsset(iqm, "data/iqm/mrfixit.iqm");
        
        aCar = New!OBJAsset(assetManager);
        addAsset(aCar, "data/car/jeep.obj");
        
        aTexCarDiffuse = addTextureAsset("data/car/jeep.png");
        aTexCarNormal = addTextureAsset("data/car/jeep-normal.png");

        aWheel = New!OBJAsset(assetManager);
        addAsset(aWheel, "data/car/wheel.obj");
    }

    override void onAllocate()
    {
        super.onAllocate();
        
        // Configure environment
        environment.useSkyColors = true;
        environment.atmosphericFog = true;
        
        // Create camera and view
        auto eCamera = createEntity3D();
        eCamera.position = Vector3f(25.0f, 5.0f, 0.0f);
        fpview = New!FirstPersonView(eventManager, eCamera, assetManager);
        fpview.camera.turn = -90.0f;
        view = fpview;
        
        // Create Framebuffers for post-processing
        fb = New!Framebuffer(eventManager.windowWidth, eventManager.windowHeight, assetManager);
        fbAA = New!Framebuffer(eventManager.windowWidth, eventManager.windowHeight, assetManager);
        fxaa = New!PostFilterFXAA(fb, assetManager);
        lens = New!PostFilterLensDistortion(fbAA, assetManager);

        // Create material backends
        shadelessMatBackend = New!ShadelessBackend(assetManager);
        skyMatBackend = New!SkyBackend(assetManager);
        
        // Create materials
        auto matDefault = createMaterial();
        
        auto matImrod = createMaterial();
        matImrod.diffuse = aTexImrodDiffuse.texture;
        matImrod.normal = aTexImrodNormal.texture;

        auto mStone = createMaterial();
        mStone.diffuse = aTexStoneDiffuse.texture;
        mStone.normal = aTexStoneNormal.texture;
        mStone.height = aTexStoneHeight.texture;
        mStone.roughness = 0.2f;
        mStone.parallax = ParallaxSimple; //also try ParallaxOcclusionMapping
        
        auto mGround = createMaterial();
        mGround.diffuse = aTexStone2Diffuse.texture;
        mGround.normal = aTexStone2Normal.texture;
        mGround.height = aTexStone2Height.texture;
        mGround.roughness = 0.1f;
        mGround.parallax = ParallaxSimple;
        
        auto mCrate = createMaterial();
        mCrate.diffuse = aTexCrateDiffuse.texture;
        mCrate.roughness = 0.9f;
        
        auto matCar = createMaterial();
        matCar.diffuse = aTexCarDiffuse.texture;
        matCar.normal = aTexCarNormal.texture;
        
        auto matSky = createMaterial(skyMatBackend);
        matSky.depthWrite = false;
        
        // Create skydome entity
        eSky = createEntity3D();
        eSky.attach = Attach.Camera;
        eSky.castShadow = false;
        eSky.material = matSky;
        eSky.drawable = aSphere.mesh;
        eSky.scaling = Vector3f(100.0f, 100.0f, 100.0f);

        // Create castle entity
        Entity eCastle = createEntity3D();
        eCastle.drawable = aCastle.mesh;
        eCastle.material = mStone;
        
        // Create Imrod entity
        Entity eImrod = createEntity3D();
        eImrod.material = matImrod;
        eImrod.drawable = aImrod.mesh;
        eImrod.position.x = -2.0f;
        eImrod.scaling = Vector3f(0.5, 0.5, 0.5);
        
        // Create Mr Fixit entity (animated model)
        actor = New!Actor(iqm.model, assetManager);
        eMrfixit = createEntity3D();
        eMrfixit.drawable = actor;
        eMrfixit.material = matDefault;
        eMrfixit.position.x = 2.0f;
        eMrfixit.rotation = rotationQuaternion(Axis.y, degtorad(-90.0f));
        eMrfixit.scaling = Vector3f(0.25, 0.25, 0.25);
        eMrfixit.defaultController.swapZY = true;
        
        // Create physics world 
        world = New!PhysicsWorld();

        // Create BVH for castle model to handle collisions
        Mesh[] meshes = [aCastle.mesh];
        bvh = meshBVH(meshes);
        world.bvhRoot = bvh.root;
        
        // Create ground plane
        RigidBody bGround = world.addStaticBody(Vector3f(0.0f, 0.0f, 0.0f));
        gGround = New!GeomBox(Vector3f(100.0f, 1.0f, 100.0f));
        world.addShapeComponent(bGround, gGround, Vector3f(0.0f, -1.0f, 0.0f), 1.0f);
        auto eGround = createEntity3D();
        eGround.drawable = New!ShapePlane(200, 200, 100, assetManager);
        eGround.material = mGround;

        // Create dmech geometries for dynamic objects
        gLightBall = New!GeomSphere(lightBallRadius);
        gSphere = New!GeomEllipsoid(Vector3f(0.9f, 1.0f, 0.9f));
        
        // Create character controller
        character = New!CharacterController(world, fpview.camera.position, 80.0f, gSphere, assetManager);
        gSensor = New!GeomBox(Vector3f(0.5f, 0.5f, 0.5f));
        character.createSensor(gSensor, Vector3f(0.0f, -0.75f, 0.0f));

        // Create boxes
        gCrate = New!GeomBox(Vector3f(1.0f, 1.0f, 1.0f));
        foreach(i; 0..5)
        {
            auto eCrate = createEntity3D();
            eCrate.drawable = aCrate.mesh;
            eCrate.material = mCrate;
            eCrate.position = Vector3f(i * 0.1f, 3.0f + 3.0f * cast(float)i, -5.0f);
            auto bCrate = world.addDynamicBody(Vector3f(0, 0, 0), 0.0f);
            RigidBodyController rbc = New!RigidBodyController(eCrate, bCrate);
            eCrate.controller = rbc;
            world.addShapeComponent(bCrate, gCrate, Vector3f(0.0f, 0.0f, 0.0f), 10.0f);
        }        
        
        // Create car
        Entity eCar = createEntity3D();
        eCar.drawable = aCar.mesh;
        eCar.material = matCar;
        eCar.position = Vector3f(30.0f, 5.0f, 0.0f);

        gBox = New!GeomBox(Vector3f(2.2f, 0.5f, 3.3f));
        auto b = world.addDynamicBody(Vector3f(0, 0, 0), 0.0f);
        b.raycastable = false;
        vehicle = New!VehicleController(eCar, b, world);
        eCar.controller = vehicle;
        world.addShapeComponent(b, gBox, Vector3f(0.0f, 2.0f, 0.0f), 2000.0f);
        b.centerOfMass.y = -0.9f;
        
        foreach(ref w; eWheels)
        {
            w = createEntity3D(eCar);
            w.drawable = aWheel.mesh;
            w.material = matCar;
        }
        
        carView = New!CarView(eventManager, vehicle, assetManager);
        carViewEnabled = false;
        
        initializedPhysics = true;
        
        // Create particle system
        auto mParticles = createMaterial(shadelessMatBackend); // TODO: a specialized particle material backend
        mParticles.diffuse = aTexParticle.texture;
        mParticles.blending = Additive;
        mParticles.depthWrite = false;
        eParticles = createEntity3D();
        eParticles.position.x = 4.0f;
        eParticles.position.y = 0.6f;
        ParticleSystem psys = New!ParticleSystem(eParticles, 100, view);
        psys.material = mParticles;
        
        // Create vortex force field for particles
        auto eVortex = createEntity3D();
        eVortex.position = Vector3f(0, 0, 0);
        eVortex.rotation = rotationQuaternion(0, degtorad(-90.0f));
        auto ff1 = New!Vortex(eVortex, psys, 100, 10);
        
        // Create HUD text
        auto text = New!TextLine(aFont.font, 
            "Press <LMB> to switch mouse look, WASD to move, spacebar to jump, Enter to get in the car, <RMB> to create a light, arrow keys to rotate the sun", 
            assetManager);
        text.color = Color4f(1.0f, 1.0f, 1.0f, 0.7f);
        
        auto eText = createEntity2D();
        eText.drawable = text;
        eText.position = Vector3f(16.0f, 30.0f, 0.0f);
        
        dynamicText = New!TextLine(aFont.font, "0", assetManager);
        dynamicText.color = Color4f(1.0f, 1.0f, 1.0f, 0.7f);
        
        auto eText2 = createEntity2D();
        eText2.drawable = dynamicText;
        eText2.position = Vector3f(16.0f, 60.0f, 0.0f);
    }
    
    override void onStart()
    {
        super.onStart();
        actor.play();
    }
    
    override void onKeyDown(int key)
    {
        if (key == KEY_ESCAPE)
            exitApplication();
        else if (key == KEY_RETURN)
        {
            if (carViewEnabled)
            {
                view = fpview;
                carViewEnabled = false;
                character.rbody.active = true;
                character.rbody.position = vehicle.rbody.position + vehicle.rbody.orientation.rotate(Vector3f(1.0f, 0.0f, 0.0f).normalized) * 4.0f + Vector3f(0, 3, 0);
            }
            else if (distance(fpview.cameraPosition, vehicle.rbody.position) <= 4.0f)
            {
                view = carView;
                carViewEnabled = true;
                character.rbody.active = false;
            }
        }
    }
    
    override void onMouseButtonDown(int button)
    {
        // Toggle mouse look / cursor lock
        if (button == MB_LEFT)
        {
            if (fpview.active)
                fpview.active = false;
            else
                fpview.active = true;
        }
        
        // Create a light ball
        if (button == MB_RIGHT && !carViewEnabled)
        {
            Vector3f pos = fpview.camera.position + fpview.camera.characterMatrix.forward * -2.0f + Vector3f(0, 1, 0);
            Color4f color = lightColors[uniform(0, 9)];
            createLightBall(pos, color, lightBallRadius, 4.0f);
        }
    }
    
    Entity createLightBall(Vector3f pos, Color4f color, float areaRadius, float volumeRadius)
    {
        auto light = createLight(pos, color, volumeRadius, areaRadius);
            
        if (light)
        {
            auto mLightBall = createMaterial(shadelessMatBackend);
            mLightBall.diffuse = color;
                
            auto eLightBall = createEntity3D();
            eLightBall.drawable = aSphere.mesh;
            eLightBall.scaling = Vector3f(-areaRadius, -areaRadius, -areaRadius);
            eLightBall.castShadow = false;
            eLightBall.material = mLightBall;
            eLightBall.position = pos;
            auto bLightBall = world.addDynamicBody(Vector3f(0, 0, 0), 0.0f);
            RigidBodyController rbc = New!RigidBodyController(eLightBall, bLightBall);
            eLightBall.controller = rbc;
            world.addShapeComponent(bLightBall, gLightBall, Vector3f(0.0f, 0.0f, 0.0f), 10.0f);
                
            LightBehaviour lc = New!LightBehaviour(eLightBall, light);
            
            return eLightBall;
        }
        
        return null;
    }
    
    // Character control
    void updateCharacter(double dt)
    { 
        character.rotation.y = fpview.camera.turn;
        Vector3f forward = fpview.camera.characterMatrix.forward;
        Vector3f right = fpview.camera.characterMatrix.right; 
        float speed = 8.0f;
        Vector3f dir = Vector3f(0, 0, 0);
        if (eventManager.keyPressed[KEY_W]) dir += -forward;
        if (eventManager.keyPressed[KEY_S]) dir += forward;
        if (eventManager.keyPressed[KEY_A]) dir += -right;
        if (eventManager.keyPressed[KEY_D]) dir += right;
        character.move(dir.normalized, speed);
        if (eventManager.keyPressed[KEY_SPACE]) character.jump(2.0f);
        character.update();
    }

    void updateVehicle(double dt)
    {
        if (carViewEnabled)
        {
            if (eventManager.keyPressed[KEY_W])
                vehicle.accelerateForward(200.0f);
            else if (eventManager.keyPressed[KEY_S])
                vehicle.accelerateBackward(200.0f);
            else
                vehicle.brake = false;

            if (eventManager.keyPressed[KEY_A])
                vehicle.steer(-2.0f);
            else if (eventManager.keyPressed[KEY_D])
                vehicle.steer(2.0f);
            else
                vehicle.resetSteering();
        }
        
        vehicle.fixedStepUpdate(dt);
        
        foreach(i, ref w; eWheels)
        {
            auto vWheel = vehicle.wheels[i];
            w.position = vWheel.position;
            
            w.rotation = rotationQuaternion(Axis.y, degtorad(-vWheel.steeringAngle)) * 
                         rotationQuaternion(Axis.x, degtorad(vWheel.roll));
        }
    }
    
    override void onLogicsUpdate(double dt)
    {
        // Update our character and physics
        if (!carViewEnabled)
            updateCharacter(dt);
        
        updateVehicle(dt);
        world.update(dt);
        
        // Place camera to character controller position
        // TODO: maybe make character controller an Entity, so that
        // this could be done automatically with parenting mechanism?
        fpview.camera.position = character.rbody.position;
        
        // Circular motion of a particle emitter
        eParticles.position = Vector3f(cos(rc3d.time), 1.0f, sin(rc3d.time)) * 5.0f;
        
        // Sun control
        if (eventManager.keyPressed[KEY_DOWN]) sunPitch += 30.0f * dt;
        if (eventManager.keyPressed[KEY_UP]) sunPitch -= 30.0f * dt;
        if (eventManager.keyPressed[KEY_LEFT]) sunTurn += 30.0f * dt;
        if (eventManager.keyPressed[KEY_RIGHT]) sunTurn -= 30.0f * dt;
        environment.sunRotation = 
            rotationQuaternion(Axis.y, degtorad(sunTurn)) * 
            rotationQuaternion(Axis.x, degtorad(sunPitch));

        // Update dynamicText with some debug info
        uint n = sprintf(lightsText.ptr, 
            "FPS: %u | visible lights: %u | total lights: %u | max visible lights: %u", 
            eventManager.fps, 
            lightManager.currentlyVisibleLights, 
            lightManager.lightSources.length, 
            lightManager.maxNumLights);
        string s = cast(string)lightsText[0..n];
        dynamicText.setText(s);
    }
    
    char[100] lightsText;
    
    override void onRender()
    {
        // Render shadow map
        renderShadows(&rc3d);
        
        // Render 3D objects to fb for FXAA
        fb.bind();
        prepareViewport();        
        renderEntities3D(&rc3d);
        fb.unbind();
        
        // Render fxaa quad to fbAA for lens distortion
        fbAA.bind();
        prepareViewport();
        fxaa.render(&rc2d);
        fbAA.unbind();
        
        // Render lens distortion quad and 2D objects to main framebuffer
        prepareViewport();
        lens.render(&rc2d);
        renderEntities2D(&rc2d);
    }
    
    override void onRelease()
    {
        super.onRelease();
        
        // If we have created dmech objects, we should release them
        if (initializedPhysics)
        {
            Delete(world);
            Delete(gGround);
            Delete(gLightBall);
            Delete(gSphere);
            Delete(gSensor);
            Delete(gCrate);
            Delete(gBox);
            bvh.free();
            initializedPhysics = false;
        }
    }
}

class MyApplication: SceneApplication
{
    this(string[] args)
    {
        super(1280, 720, false, "Dagon demo", args);

        TestScene test = New!TestScene(sceneManager);
        sceneManager.addScene(test, "TestScene");

        sceneManager.goToScene("TestScene");
    }
}

void main(string[] args)
{
    writeln("Allocated memory at start: ", allocatedMemory);
    MyApplication app = New!MyApplication(args);
    app.run();
    Delete(app);
    writeln("Allocated memory at end: ", allocatedMemory);
}
